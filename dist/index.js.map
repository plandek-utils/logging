{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import chalk from \"chalk\";\nimport { colorize } from \"json-colorizer\";\nimport type { Logger as PinoLogger } from \"pino\";\nimport { pino } from \"pino\";\nimport type { DeepReadonly } from \"simplytyped\";\n\nimport type {\n\tPlainObject,\n\tPlainObjectValue,\n} from \"@plandek-utils/plain-object\";\n\n/**\n * Allowed log levels for the logger.\n */\nexport const LOG_LEVELS = [\n\t\"fatal\",\n\t\"error\",\n\t\"warn\",\n\t\"info\",\n\t\"debug\",\n\t\"trace\",\n\t\"silent\",\n] as const;\n\n/**\n * Possible log levels for preparing the pino logger.\n */\nexport type LogLevel = (typeof LOG_LEVELS)[number];\n\n/**\n * Parses the given log level, or returns the default level if it's not blank. If it is an invalid level it will throw an error.\n */\nexport function parseLogLevelOrDefault(\n\tlevel: string | null | undefined,\n\tdefaultLevel: LogLevel,\n): LogLevel {\n\tif (!level) return defaultLevel;\n\n\tconst lowerLevel = level.toLowerCase() as LogLevel;\n\tif (LOG_LEVELS.includes(lowerLevel)) {\n\t\treturn lowerLevel;\n\t}\n\n\tthrow new Error(`Invalid log level: ${level}`);\n}\n\n/**\n * Prepared pino logger, returned by `buildPinoLogger` or `buildSinkLogger`.\n *\n * @see buildPinoLogger\n * @see buildSinkLogger\n */\nexport type PreparedLogger = Pick<\n\tPinoLogger,\n\t\"level\" | \"info\" | \"debug\" | \"warn\" | \"error\" | \"bindings\"\n> & {\n\tchild: (bindings: PlainObject) => PreparedLogger;\n};\n\n/**\n * Prepares a Pino logger with the common configuration.\n *\n * @param level - The log level to use.\n * @param redactPaths - Paths to redact from the logs. Defaults to `[\"req.headers.authorization\", \"req.headers.cookie\"]`.\n * @returns PinoLogger\n */\nexport function buildPinoLogger(\n\tlevel: LogLevel,\n\tredactPaths?: string[],\n): PreparedLogger {\n\tconst paths = redactPaths ?? [\n\t\t\"req.headers.authorization\",\n\t\t\"req.headers.cookie\",\n\t];\n\treturn pino({\n\t\tlevel,\n\t\ttimestamp: pino.stdTimeFunctions.isoTime,\n\t\tredact: { paths, censor: \"[REDACTED]\" },\n\t});\n}\n\n/**\n * A mock logger that does nothing, holds no binding (sections).\n */\nexport function buildSinkLogger(\n\tlevel: LogLevel,\n\tgivenBindings?: PlainObject,\n): PreparedLogger {\n\tconst bindings = givenBindings ?? {};\n\treturn {\n\t\tlevel,\n\t\tinfo: () => {},\n\t\tdebug: () => {},\n\t\twarn: () => {},\n\t\terror: () => {},\n\t\tchild: (childBindings?: PlainObject) =>\n\t\t\tbuildSinkLogger(level, { ...bindings, ...childBindings }),\n\t\tbindings: () => bindings,\n\t};\n}\n\n/**\n * Util to serialise as JSON the given value, pretty-printed (2 spaces).\n */\nexport function prettyJSON(obj: unknown): string {\n\treturn JSON.stringify(obj, null, 2);\n}\n\n/**\n * Calls `prettyJSON` and then colourises the output.\n */\nexport function colourPrettyJSON(obj: unknown): string {\n\treturn colorize(prettyJSON(obj));\n}\n\n/**\n * Alias for `colourPrettyJSON`.\n * @see colourPrettyJSON\n */\nexport const colorPrettyJSON = colourPrettyJSON;\n\n/**\n * Interface to provide colouring for logs.\n */\nexport type LogColourUtils = {\n\tblue: (x: string) => string;\n\tcyan: (x: string) => string;\n\tgray: (x: string) => string;\n\tmagenta: (x: string) => string;\n\tred: (x: string) => string;\n\tyellow: (x: string) => string;\n};\n\n/**\n * Creates a LogColourUtils object, with actual colours or not depending on the given mode.\n *\n * @param mode: if \"with-colour\", it will return a set of functions that will colour the given string. If \"plain\", it will return a set of functions that will return the string as is.\n */\nexport function makeColourUtils(mode: \"with-colour\" | \"plain\"): LogColourUtils {\n\tif (mode === \"with-colour\") {\n\t\treturn {\n\t\t\tblue: (x: string) => chalk.blue(x),\n\t\t\tcyan: (x: string) => chalk.cyan(x),\n\t\t\tgray: (x: string) => chalk.gray(x),\n\t\t\tmagenta: (x: string) => chalk.magenta(x),\n\t\t\tred: (x: string) => chalk.red(x),\n\t\t\tyellow: (x: string) => chalk.yellow(x),\n\t\t};\n\t}\n\n\tif (mode === \"plain\") {\n\t\treturn {\n\t\t\tblue: (x: string) => x,\n\t\t\tcyan: (x: string) => x,\n\t\t\tgray: (x: string) => x,\n\t\t\tmagenta: (x: string) => x,\n\t\t\tred: (x: string) => x,\n\t\t\tyellow: (x: string) => x,\n\t\t};\n\t}\n\n\tconst _never: never = mode;\n\tthrow new Error(`Unknown mode: ${_never}`);\n}\n\n/**\n * Logging interface. Requires a message (string) and optionally an object to log, which is required to be a Plain Object to ensure serialisation.\n */\ntype LogFn = (msg: string, obj?: DeepReadonly<PlainObject>) => void;\n\n/**\n * Logging interface that provides a way to log messages with different levels. It should be configured with sections. It can return a new instance with a new section.\n */\nexport type Logging = {\n\tlogger: PreparedLogger;\n\tinfo: LogFn;\n\twarn: LogFn;\n\tdebug: LogFn;\n\terror: LogFn;\n\tgetSections(this: Logging): string[];\n\twithSection(this: Logging, section: string, context?: PlainObject): Logging;\n};\n\n/**\n * Variant of the Logging interface that stores the messages that have been logged.\n */\nexport type LoggingWithRecords = Omit<Logging, \"withSection\"> & {\n\twithSection(\n\t\tthis: Logging,\n\t\tsection: string,\n\t\tcontext?: PlainObject,\n\t): LoggingWithRecords;\n\tmessages: {\n\t\tinfo: Array<[string, PlainObject | null]>;\n\t\twarn: Array<[string, PlainObject | null]>;\n\t\tdebug: Array<[string, PlainObject | null]>;\n\t\terror: Array<[string, PlainObject | null]>;\n\t};\n};\n\n/**\n * Checks if the given Logging object is a LoggingWithRecords.\n * @param obj\n * @returns\n */\nexport function isLoggingWithRecords(obj: Logging): obj is LoggingWithRecords {\n\treturn \"messages\" in obj;\n}\n\n/**\n * Creates a Logging object. It requires an actual pino logger to be sent, and optionally a section and a context.\n */\nexport function makeLogging(opts: {\n\tsection?: string;\n\tcontext?: PlainObject;\n\tlogger: PreparedLogger;\n}): Logging {\n\tconst logger = loggerFor(\n\t\topts.logger,\n\t\topts.section ?? null,\n\t\topts.context ?? null,\n\t);\n\n\treturn {\n\t\tlogger,\n\t\tinfo: (msg, obj) => logger.info(obj, msg),\n\t\tdebug: (msg, obj) => logger.debug(obj, msg),\n\t\twarn: (msg, obj) => logger.warn(obj, msg),\n\t\terror: (msg, obj) => logger.error(obj, msg),\n\t\tgetSections(): string[] {\n\t\t\treturn getSectionsFromLogger(logger);\n\t\t},\n\t\twithSection(section, context) {\n\t\t\tif (this.getSections().includes(section)) return this;\n\n\t\t\treturn makeLogging({ logger: this.logger, section, context });\n\t\t},\n\t};\n}\n\n/**\n * Creates a LoggingWithRecords object. It requires an actual pino logger to be sent, and optionally a section and a context. You can pass it a \"messages\" record object to use or a new one will be created.\n */\nexport function makeLoggingWithRecord(opts: {\n\tlogger: PreparedLogger;\n\tsection?: string;\n\tcontext?: PlainObject;\n\tmessages?: LoggingWithRecords[\"messages\"];\n}): LoggingWithRecords {\n\tconst logging = makeLogging(opts);\n\tconst messages = opts.messages ?? {\n\t\tinfo: [],\n\t\twarn: [],\n\t\tdebug: [],\n\t\terror: [],\n\t};\n\n\tfunction makeLogFn(logFn: LogFn, key: keyof typeof messages): LogFn {\n\t\treturn (msg, obj) => {\n\t\t\tmessages[key].push([msg, obj ?? null]);\n\t\t\treturn logFn(msg, obj);\n\t\t};\n\t}\n\n\treturn {\n\t\tmessages,\n\t\tlogger: logging.logger,\n\t\tinfo: makeLogFn(logging.info, \"info\"),\n\t\tdebug: makeLogFn(logging.debug, \"debug\"),\n\t\twarn: makeLogFn(logging.warn, \"warn\"),\n\t\terror: makeLogFn(logging.error, \"error\"),\n\t\tgetSections(): string[] {\n\t\t\treturn logging.getSections();\n\t\t},\n\t\twithSection(section, context) {\n\t\t\treturn makeLoggingWithRecord({\n\t\t\t\tlogger: this.logger,\n\t\t\t\tsection,\n\t\t\t\tmessages,\n\t\t\t\tcontext,\n\t\t\t});\n\t\t},\n\t};\n}\n\n// INTERNAL\n\nfunction loggerFor(\n\tgivenLogger: PreparedLogger,\n\tsection: string | null,\n\tcontext: PlainObject | null,\n) {\n\tif (!context && (!section || loggerHasSection(givenLogger, section))) {\n\t\treturn givenLogger;\n\t}\n\n\tconst childBindings: Record<string, PlainObjectValue> = { ...context };\n\tif (section) {\n\t\tchildBindings.logSections = [\n\t\t\t...getSectionsFromLogger(givenLogger),\n\t\t\tsection,\n\t\t];\n\t}\n\n\treturn givenLogger.child(childBindings);\n}\n\nfunction getSectionsFromLogger(logger: PreparedLogger) {\n\treturn logger.bindings().logSections ?? [];\n}\n\nfunction loggerHasSection(logger: PreparedLogger, section: string) {\n\tconst sections = getSectionsFromLogger(logger);\n\treturn sections.includes(section);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAClB,4BAAyB;AAEzB,kBAAqB;AAWd,IAAM,aAAa;AAAA,EACzB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD;AAUO,SAAS,uBACf,OACA,cACW;AACX,MAAI,CAAC,MAAO,QAAO;AAEnB,QAAM,aAAa,MAAM,YAAY;AACrC,MAAI,WAAW,SAAS,UAAU,GAAG;AACpC,WAAO;AAAA,EACR;AAEA,QAAM,IAAI,MAAM,sBAAsB,KAAK,EAAE;AAC9C;AAsBO,SAAS,gBACf,OACA,aACiB;AACjB,QAAM,QAAQ,eAAe;AAAA,IAC5B;AAAA,IACA;AAAA,EACD;AACA,aAAO,kBAAK;AAAA,IACX;AAAA,IACA,WAAW,iBAAK,iBAAiB;AAAA,IACjC,QAAQ,EAAE,OAAO,QAAQ,aAAa;AAAA,EACvC,CAAC;AACF;AAKO,SAAS,gBACf,OACA,eACiB;AACjB,QAAM,WAAW,iBAAiB,CAAC;AACnC,SAAO;AAAA,IACN;AAAA,IACA,MAAM,MAAM;AAAA,IAAC;AAAA,IACb,OAAO,MAAM;AAAA,IAAC;AAAA,IACd,MAAM,MAAM;AAAA,IAAC;AAAA,IACb,OAAO,MAAM;AAAA,IAAC;AAAA,IACd,OAAO,CAAC,kBACP,gBAAgB,OAAO,EAAE,GAAG,UAAU,GAAG,cAAc,CAAC;AAAA,IACzD,UAAU,MAAM;AAAA,EACjB;AACD;AAKO,SAAS,WAAW,KAAsB;AAChD,SAAO,KAAK,UAAU,KAAK,MAAM,CAAC;AACnC;AAKO,SAAS,iBAAiB,KAAsB;AACtD,aAAO,gCAAS,WAAW,GAAG,CAAC;AAChC;AAMO,IAAM,kBAAkB;AAmBxB,SAAS,gBAAgB,MAA+C;AAC9E,MAAI,SAAS,eAAe;AAC3B,WAAO;AAAA,MACN,MAAM,CAAC,MAAc,aAAAA,QAAM,KAAK,CAAC;AAAA,MACjC,MAAM,CAAC,MAAc,aAAAA,QAAM,KAAK,CAAC;AAAA,MACjC,MAAM,CAAC,MAAc,aAAAA,QAAM,KAAK,CAAC;AAAA,MACjC,SAAS,CAAC,MAAc,aAAAA,QAAM,QAAQ,CAAC;AAAA,MACvC,KAAK,CAAC,MAAc,aAAAA,QAAM,IAAI,CAAC;AAAA,MAC/B,QAAQ,CAAC,MAAc,aAAAA,QAAM,OAAO,CAAC;AAAA,IACtC;AAAA,EACD;AAEA,MAAI,SAAS,SAAS;AACrB,WAAO;AAAA,MACN,MAAM,CAAC,MAAc;AAAA,MACrB,MAAM,CAAC,MAAc;AAAA,MACrB,MAAM,CAAC,MAAc;AAAA,MACrB,SAAS,CAAC,MAAc;AAAA,MACxB,KAAK,CAAC,MAAc;AAAA,MACpB,QAAQ,CAAC,MAAc;AAAA,IACxB;AAAA,EACD;AAEA,QAAM,SAAgB;AACtB,QAAM,IAAI,MAAM,iBAAiB,MAAM,EAAE;AAC1C;AA0CO,SAAS,qBAAqB,KAAyC;AAC7E,SAAO,cAAc;AACtB;AAKO,SAAS,YAAY,MAIhB;AACX,QAAM,SAAS;AAAA,IACd,KAAK;AAAA,IACL,KAAK,WAAW;AAAA,IAChB,KAAK,WAAW;AAAA,EACjB;AAEA,SAAO;AAAA,IACN;AAAA,IACA,MAAM,CAAC,KAAK,QAAQ,OAAO,KAAK,KAAK,GAAG;AAAA,IACxC,OAAO,CAAC,KAAK,QAAQ,OAAO,MAAM,KAAK,GAAG;AAAA,IAC1C,MAAM,CAAC,KAAK,QAAQ,OAAO,KAAK,KAAK,GAAG;AAAA,IACxC,OAAO,CAAC,KAAK,QAAQ,OAAO,MAAM,KAAK,GAAG;AAAA,IAC1C,cAAwB;AACvB,aAAO,sBAAsB,MAAM;AAAA,IACpC;AAAA,IACA,YAAY,SAAS,SAAS;AAC7B,UAAI,KAAK,YAAY,EAAE,SAAS,OAAO,EAAG,QAAO;AAEjD,aAAO,YAAY,EAAE,QAAQ,KAAK,QAAQ,SAAS,QAAQ,CAAC;AAAA,IAC7D;AAAA,EACD;AACD;AAKO,SAAS,sBAAsB,MAKf;AACtB,QAAM,UAAU,YAAY,IAAI;AAChC,QAAM,WAAW,KAAK,YAAY;AAAA,IACjC,MAAM,CAAC;AAAA,IACP,MAAM,CAAC;AAAA,IACP,OAAO,CAAC;AAAA,IACR,OAAO,CAAC;AAAA,EACT;AAEA,WAAS,UAAU,OAAc,KAAmC;AACnE,WAAO,CAAC,KAAK,QAAQ;AACpB,eAAS,GAAG,EAAE,KAAK,CAAC,KAAK,OAAO,IAAI,CAAC;AACrC,aAAO,MAAM,KAAK,GAAG;AAAA,IACtB;AAAA,EACD;AAEA,SAAO;AAAA,IACN;AAAA,IACA,QAAQ,QAAQ;AAAA,IAChB,MAAM,UAAU,QAAQ,MAAM,MAAM;AAAA,IACpC,OAAO,UAAU,QAAQ,OAAO,OAAO;AAAA,IACvC,MAAM,UAAU,QAAQ,MAAM,MAAM;AAAA,IACpC,OAAO,UAAU,QAAQ,OAAO,OAAO;AAAA,IACvC,cAAwB;AACvB,aAAO,QAAQ,YAAY;AAAA,IAC5B;AAAA,IACA,YAAY,SAAS,SAAS;AAC7B,aAAO,sBAAsB;AAAA,QAC5B,QAAQ,KAAK;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,MACD,CAAC;AAAA,IACF;AAAA,EACD;AACD;AAIA,SAAS,UACR,aACA,SACA,SACC;AACD,MAAI,CAAC,YAAY,CAAC,WAAW,iBAAiB,aAAa,OAAO,IAAI;AACrE,WAAO;AAAA,EACR;AAEA,QAAM,gBAAkD,EAAE,GAAG,QAAQ;AACrE,MAAI,SAAS;AACZ,kBAAc,cAAc;AAAA,MAC3B,GAAG,sBAAsB,WAAW;AAAA,MACpC;AAAA,IACD;AAAA,EACD;AAEA,SAAO,YAAY,MAAM,aAAa;AACvC;AAEA,SAAS,sBAAsB,QAAwB;AACtD,SAAO,OAAO,SAAS,EAAE,eAAe,CAAC;AAC1C;AAEA,SAAS,iBAAiB,QAAwB,SAAiB;AAClE,QAAM,WAAW,sBAAsB,MAAM;AAC7C,SAAO,SAAS,SAAS,OAAO;AACjC;","names":["chalk"]}