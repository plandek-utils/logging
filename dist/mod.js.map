{"version":3,"sources":["../src/mod.ts"],"sourcesContent":["import chalk from \"chalk\";\nimport { colorize } from \"json-colorizer\";\nimport type { Logger as PinoLogger } from \"pino\";\nimport { pino } from \"pino\";\nimport type { DeepReadonly } from \"simplytyped\";\n\nimport type { PlainObject, PlainObjectValue } from \"@plandek-utils/plain-object\";\n\n/**\n * Allowed log levels for the logger.\n */\nexport const LOG_LEVELS = [\"fatal\", \"error\", \"warn\", \"info\", \"debug\", \"trace\", \"silent\"] as const;\n\n/**\n * Possible log levels for preparing the pino logger.\n */\nexport type LogLevel = (typeof LOG_LEVELS)[number];\n\n/**\n * Parses the given log level, or returns the default level if it's not blank. If it is an invalid level it will throw an error.\n */\nexport function parseLogLevelOrDefault(level: string | null | undefined, defaultLevel: LogLevel): LogLevel {\n  if (!level) return defaultLevel;\n\n  const lowerLevel = level.toLowerCase() as LogLevel;\n  if (LOG_LEVELS.includes(lowerLevel)) {\n    return lowerLevel;\n  }\n\n  throw new Error(`Invalid log level: ${level}`);\n}\n\n/**\n * Prepared pino logger, returned by `buildPinoLogger` or `buildSinkLogger`.\n *\n * @see buildPinoLogger\n * @see buildSinkLogger\n */\nexport type PreparedLogger = Pick<PinoLogger, \"level\" | \"info\" | \"debug\" | \"warn\" | \"error\" | \"bindings\"> & {\n  child: (bindings: PlainObject) => PreparedLogger;\n};\n\n/**\n * Prepares a Pino logger with the common configuration.\n *\n * @param level - The log level to use.\n * @param redactPaths - Paths to redact from the logs. Defaults to `[\"req.headers.authorization\", \"req.headers.cookie\"]`.\n * @returns PinoLogger\n */\nexport function buildPinoLogger(level: LogLevel, redactPaths?: string[]): PreparedLogger {\n  const paths = redactPaths ?? [\"req.headers.authorization\", \"req.headers.cookie\"];\n  return pino({\n    level,\n    timestamp: pino.stdTimeFunctions.isoTime,\n    redact: { paths, censor: \"[REDACTED]\" },\n  });\n}\n\n/**\n * A mock logger that does nothing, holds no binding (sections).\n */\nexport function buildSinkLogger(level: LogLevel, givenBindings?: PlainObject): PreparedLogger {\n  const bindings = givenBindings ?? {};\n  return {\n    level,\n    info: () => {},\n    debug: () => {},\n    warn: () => {},\n    error: () => {},\n    child: (childBindings?: PlainObject) => buildSinkLogger(level, { ...bindings, ...childBindings }),\n    bindings: () => bindings,\n  };\n}\n\n/**\n * Util to serialise as JSON the given value, pretty-printed (2 spaces).\n */\nexport function prettyJSON(obj: unknown): string {\n  return JSON.stringify(obj, null, 2);\n}\n\n/**\n * Calls `prettyJSON` and then colourises the output.\n */\nexport function colourPrettyJSON(obj: unknown): string {\n  return colorize(prettyJSON(obj));\n}\n\n/**\n * Alias for `colourPrettyJSON`.\n * @see colourPrettyJSON\n */\nexport const colorPrettyJSON = colourPrettyJSON;\n\n/**\n * Interface to provide colouring for logs.\n */\nexport type LogColourUtils = {\n  blue: (x: string) => string;\n  cyan: (x: string) => string;\n  gray: (x: string) => string;\n  magenta: (x: string) => string;\n  red: (x: string) => string;\n  yellow: (x: string) => string;\n};\n\n/**\n * Creates a LogColourUtils object, with actual colours or not depending on the given mode.\n *\n * @param mode: if \"with-colour\", it will return a set of functions that will colour the given string. If \"plain\", it will return a set of functions that will return the string as is.\n */\nexport function makeColourUtils(mode: \"with-colour\" | \"plain\"): LogColourUtils {\n  if (mode === \"with-colour\") {\n    return {\n      blue: (x: string) => chalk.blue(x),\n      cyan: (x: string) => chalk.cyan(x),\n      gray: (x: string) => chalk.gray(x),\n      magenta: (x: string) => chalk.magenta(x),\n      red: (x: string) => chalk.red(x),\n      yellow: (x: string) => chalk.yellow(x),\n    };\n  }\n\n  if (mode === \"plain\") {\n    return {\n      blue: (x: string) => x,\n      cyan: (x: string) => x,\n      gray: (x: string) => x,\n      magenta: (x: string) => x,\n      red: (x: string) => x,\n      yellow: (x: string) => x,\n    };\n  }\n\n  const _never: never = mode;\n  throw new Error(`Unknown mode: ${_never}`);\n}\n\n/**\n * Logging interface. Requires a message (string) and optionally an object to log, which is required to be a Plain Object to ensure serialisation.\n */\ntype LogFn = (msg: string, obj?: DeepReadonly<PlainObject>) => void;\n\n/**\n * Logging interface that provides a way to log messages with different levels. It should be configured with sections. It can return a new instance with a new section.\n */\nexport type Logging = {\n  logger: PreparedLogger;\n  info: LogFn;\n  warn: LogFn;\n  debug: LogFn;\n  error: LogFn;\n  getSections(this: Logging): string[];\n  withSection(this: Logging, section: string, context?: PlainObject): Logging;\n};\n\n/**\n * Variant of the Logging interface that stores the messages that have been logged.\n */\nexport type LoggingWithRecords = Omit<Logging, \"withSection\"> & {\n  withSection(this: Logging, section: string, context?: PlainObject): LoggingWithRecords;\n  messages: {\n    info: Array<[string, PlainObject | null]>;\n    warn: Array<[string, PlainObject | null]>;\n    debug: Array<[string, PlainObject | null]>;\n    error: Array<[string, PlainObject | null]>;\n  };\n};\n\n/**\n * Checks if the given Logging object is a LoggingWithRecords.\n * @param obj\n * @returns\n */\nexport function isLoggingWithRecords(obj: Logging): obj is LoggingWithRecords {\n  return \"messages\" in obj;\n}\n\n/**\n * Creates a Logging object. It requires an actual pino logger to be sent, and optionally a section and a context.\n */\nexport function makeLogging(opts: {\n  section?: string;\n  context?: PlainObject;\n  logger: PreparedLogger;\n}): Logging {\n  const logger = loggerFor(opts.logger, opts.section ?? null, opts.context ?? null);\n\n  return {\n    logger,\n    info: (msg, obj) => logger.info(obj, msg),\n    debug: (msg, obj) => logger.debug(obj, msg),\n    warn: (msg, obj) => logger.warn(obj, msg),\n    error: (msg, obj) => logger.error(obj, msg),\n    getSections(): string[] {\n      return getSectionsFromLogger(logger);\n    },\n    withSection(section, context) {\n      if (this.getSections().includes(section)) return this;\n\n      return makeLogging({ logger: this.logger, section, context });\n    },\n  };\n}\n\n/**\n * Creates a LoggingWithRecords object. It requires an actual pino logger to be sent, and optionally a section and a context. You can pass it a \"messages\" record object to use or a new one will be created.\n */\nexport function makeLoggingWithRecord(opts: {\n  logger: PreparedLogger;\n  section?: string;\n  context?: PlainObject;\n  messages?: LoggingWithRecords[\"messages\"];\n}): LoggingWithRecords {\n  const logging = makeLogging(opts);\n  const messages = opts.messages ?? {\n    info: [],\n    warn: [],\n    debug: [],\n    error: [],\n  };\n\n  function makeLogFn(logFn: LogFn, key: keyof typeof messages): LogFn {\n    return (msg, obj) => {\n      messages[key].push([msg, obj ?? null]);\n      return logFn(msg, obj);\n    };\n  }\n\n  return {\n    messages,\n    logger: logging.logger,\n    info: makeLogFn(logging.info, \"info\"),\n    debug: makeLogFn(logging.debug, \"debug\"),\n    warn: makeLogFn(logging.warn, \"warn\"),\n    error: makeLogFn(logging.error, \"error\"),\n    getSections(): string[] {\n      return logging.getSections();\n    },\n    withSection(section, context) {\n      return makeLoggingWithRecord({\n        logger: this.logger,\n        section,\n        messages,\n        context,\n      });\n    },\n  };\n}\n\n// INTERNAL\n\nfunction loggerFor(givenLogger: PreparedLogger, section: string | null, context: PlainObject | null) {\n  if (!context && (!section || loggerHasSection(givenLogger, section))) {\n    return givenLogger;\n  }\n\n  const childBindings: Record<string, PlainObjectValue> = { ...context };\n  if (section) {\n    childBindings.logSections = [...getSectionsFromLogger(givenLogger), section];\n  }\n\n  return givenLogger.child(childBindings);\n}\n\nfunction getSectionsFromLogger(logger: PreparedLogger) {\n  return logger.bindings().logSections ?? [];\n}\n\nfunction loggerHasSection(logger: PreparedLogger, section: string) {\n  const sections = getSectionsFromLogger(logger);\n  return sections.includes(section);\n}\n"],"mappings":"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","names":[]}